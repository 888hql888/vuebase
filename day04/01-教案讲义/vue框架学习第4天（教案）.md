# Vue框架学习 - 第4天

## 前日反馈

| ***  | 意见或建议                                                   |
| ---- | ------------------------------------------------------------ |
| ***  | 别忘了录屏哟~~~~~~**（群众的眼睛是雪亮的，忘记录屏第一时间打断告诉老师，我应该就不会忘记录屏啦！）** |
| ***  | refs那个有点不理解**（这个ref就是Vue提供给我们获取dom的一个方法，Vue在实例化编译的过程中，会将我们标记的ref节点保存到Vue实例上，所以我们就能够直接使用`this.$refs.name`直接调用了，其本质和我们使用jquery获取DOM节点的道理是一样的，都是框架封装好的一个获取dom节点方法而已，仅此而已）** |
| ***  | vue挺好玩的。**（对，vue其本质就是一个框架，并且是非常大众化的框架，只要你能get到它的点，基本上你会发现，这玩意还真不难！我们业界也都说，vue是一个学习曲线非常平缓的框架）** |



## 课程回顾

网络请求库axios的使用 

> 1. Vue专注于网络请求的一个轻量库，就是用来发请求，没有操作DOM的功能
> 2. 调用方式
>    1. `axios.get( url ).then( res => {} ).catch( err => {} )`
>    2. `axios.post( url , data ).then( res => {} ).catch( err => {} )`
> 3. 注意在成功或者失败时使用箭头函数声明回调函数，确保函数内部this指向当前vue实例对象

Vue生命周期钩子 - mounted

>   1.  声明方法，直接使用`mounted`声明一个函数即可
>   2.  执行时机，vue把内部的data和页面的内容初始化完毕并渲染挂载到页面上之后，自动执行mounted生命周期钩子函数
>   3.  mounted使用频率还是很高的，当我们碰到需要获取Vue解析的页面的DOM元素节点的时候，基本上都会写在这个钩子函数里
>   4.  mounted只会执行一次，就是HTML结构被Vue完全渲染挂载完成后
>   5.  如果data内部的数据发生改变后，DOM被更新后，则需要使用updated这个钩子函数了，updated这个钩子函数会被多次执行



## 课程目标

- 能够使用Vue.component注册全局组件
- 能够使用props把父组件给子组件传值
- 能够说出单页应用的优缺点
- 能够使用路由切换不同组件
- 能够使用编程式导航
- 能够使用动态路由匹配
- 理解Vue生命周期钩子函数created



## Vue组件的基本使用

1. vue组件的意义是什么？

   > 1. 京东首页https://www.jd.com/搜索输入框在很多地方都使用到了，如果按照咱们之前的开发方法是不是通过复制粘贴的方式来进行？有多少处，就复制粘贴多少处？这种方法是不是很low？
   > 2. 现在我们构建一个标签组合，期望这个标签组合能够一次声明多次复用，一次修正全部生效，怎么办？
   > 3. vue给我们提供了一个非常便捷的方法，叫 **组件** 封装，我们将  这些标签的组合  封装成为一个组件，在需要重复调用的之后，直接调用组件即可，定义一次随处使用，一改全部一起改，非常强大

2. vue组件是如何声明使用的呢？

   > 1. 我们先去官网简单的看一下  [组件基础](https://cn.vuejs.org/v2/guide/components.html)
   > 2. 组件的注册 `Vue.component( '组件名' , { 参数 } )`
   > 3. 在页面中调用，直接把 `组件名` 当作`标签`使用即可，一般我们使用`驼峰式命名`的方式进行声明，使用`-`拼接方式进行调用
   > 4. 参数中需要声明一个 template 属性，用来保存 html的组合标签，可以使用``包裹字符串来进行声明属性，但是体验很不好，不推荐
   > 5. 抽取组合标签，用模板 script type='text/html' id="item" 进行声明，然后给template直接传参template:"#模板id"，即可实现调用，暂时推荐使用这种方法
   > 6. 需要注意的是：组合标签必须有一个外围的包裹元素，只能有一个父节点，可以有多个子节点



##Vue组件的data和methods定义

1. 我们在组件的声明过程中，是如何声明data和methods的呢？

> 1.  声明methods和之前的没有区别，调用也是一样的调用
> 2.  声明data发生了变化，我们之前是使用对象直接声明的，data在组件内部的声明是使用**函数返回**的方式来进行声明的，调用和之前的调用方法一样，没有区别

```js
data: function() {
	return {
		message: '阿尼阿瑟哟,欧巴！'
	}
},
methods:{
    sayHello(){
        aletr('你好，Vue！')
    }
}
```

2. Vue组件 - data属性为什么用函数声明？

> 在组件中如果不是使用函数返回的方式进行data声明，则所有组件都引用同一份数据对象，任何一个组件修改了数据，所有引用数据的其他组件，都同步更新，互相干扰

![](.\assets\Snipaste_2019-08-12_16-35-11.png)

> 如果在组件中使用函数返回值进行声明data属性，则在每次调用当前组件的时候，都会执行这个函数，返回当前这个组件一个独有的数据对象，可以有效的保证互不干扰

![](.\assets\Snipaste_2019-08-12_16-34-27.png)





## 使用props实现父组件向子组件传值

什么是父子组件通信？

>   1.  谁调用组件谁就是父组件
>   2.  组件被谁调用谁就是子组件
>   3.  父组件可以在调用子组件的时候传递数据给子组件

如何实现父组件向子组件传值呢？

>   1.  第一步，咱们调用一个组件，给这个组件写几个自定义属性
>
>   ```html
>   <my-box info="这个信息可以在组件内部使用" v-bind:infoList="msg"></my-box>
>   ```
>
>   3.  第二步，在组件内部添加一个和data、methods等平级的props属性，这个属性是一个对象，里面就可以接收到咱们传递过来的数据信息，并且可以像data里面定义的数据一样拿来使用了
>
>   ```js
>   Vue.component("my-box", {
>     data() {
>         return {
>             msg: "学好vue"
>         }
>     },
>     props: {
>         //在子组件中拿到父组件的值需要进行初始化的声明和可选的默认赋值
>         info: {
>             type: String,
>             default: () => 'hello world'
>         },
>         infoList:{
>             type:String,
>             default:() => []
>         }
>     },
>     methods: {
>         sayHi() {
>             //调用和data里面的数据一模一样的调用即可
>             this.msg = this.info
>         }
>     },
>     template: "#mybox"
>   })
>   ```



##SPA单页应用基础理解

1. 什么是SPA单页应用？

   > 1. 我们打开[网易云音乐官网](https://music.163.com/)，我们发现切换路由并没有刷新页面，只是后面的后缀修改了，页面就实现了切换，并且几乎没有任何等待时间，是不是很酷，这个叫什么呢？前端路由，你完全可以先把这个理解为一个高级的tab选项卡
   > 2. 我们也将使用这种前端路由构建的应用叫做SPA单页面应用，第一次进入页面时会请求一个`html`文件，切换到其他组件，此时路径也相应变化，但是并没有新的`html`文件请求，页面内容却变化了。
   > 3. single-page application是一种特殊的Web应用。它将所有的活动局限于一个Web页面中，仅在该Web页面初始化时加载相应的HTML、JavaScript、CSS。一旦页面加载完成，SPA不会因为用户的操作而进行页面的重新加载或跳转，而是利用JavaScript动态的变换HTML（采用的是div切换显示和隐藏），从而实现UI与用户的交互。

2. 单页面应用的原理是什么？

   > **原理：** `js`会感知到`url`的变化，通过这一点可以用`js`动态地将当前页面的内容清除，然后将下一个页面的内容挂载到当前页面上。这个时候的路由不再是后端来做了，而是前端来做，判断页面显示相应的组件，清除不需要的，我们也可以先把这个理解为一个高级的tab选项卡

3. 单页应用有什么优缺点？

   |                         | 多页面应用模式MPA                                     | 单页面应用模式SPA                                            |
   | :---------------------- | :---------------------------------------------------- | ------------------------------------------------------------ |
   | **应用构成**            | 由多个完整页面构成                                    | 一个外壳页面和多个页面片段组件构成                           |
   | **跳转方式**            | 页面之间的跳转是从一个页面到另一个页面                | 一个页面组件删除或隐藏，加载另一个页面组件并显示。<br />组件间的模拟跳转，没有外壳页面 |
   | **URL模式**             | `http://xxx/page1.html`<br/>和`http://xxx/page2.html` | `http://xxx/shell.html#page1`<br/>`http://xxx/shell.html#page2` |
   | **用户体验**            | 页面间切换加载慢，不流畅，用户体验差，尤其在移动端    | 页面片段间切换快，用户体验好，包括移动设备                   |
   | **搜索引擎优化（SEO）** | 支持度高                                              | 支持度低，需要专门做SSR服务端渲染                            |



## Vue路由的基本使用  

> 1. 前面我们学习了组件，组件被声明后可以被多次互不干扰的复用，现在我们需要实现一个目标是：**按需切换显示加载我们声明的组件**，该如何实现呢？之前，我们想实现这种切换效果使用的方法是 tab 选项卡显示隐藏的方法来实现的。
> 2. 这种按需加载显示组件，我们也称作为是：**前端路由实现**，我们需要引入一个新的工具Vue Router，你也可以把这个前端路由实现理解为一个更高级的tab选项卡，我们去官网看一下这个前端路由到底是什么东东？[官网地址](https://router.vuejs.org/zh/)
> 3. Vue Router 前端路由的基础使用，实现图片切换的效果
>    1. vueRouter路由并没有集成到vue中,不是所有的项目都会用到路由
>    2. 所以我们先导包vueRouter到项目中
>    3. 用包
>       1. 先进行组件声明,准备好组件
>       2. 路由声明
>          1. 声明路由，每个路由应该映射一个组件
>          2. path 代表我们自定义一个标识,这个标识在需要的地方使用
>          3. 创建路由对象
>          4. 挂载路由
>       3. 路由调用

```html
<div id="app">
  <p>
    <!-- 使用 router-link 组件来导航. -->
    <!-- 通过传入 `to` 属性指定链接. -->
    <!-- <router-link> 默认会被渲染成一个 `<a>` 标签 -->
    <router-link to="/foo">这里换一个图片</router-link>
    <router-link to="/bar">这里换一个图片</router-link>
  </p>
  <!-- 路由出口，路由匹配到的组件将渲染在这里 -->
  <router-view></router-view>
</div>
<!--导包，需要注意先导入vue框架，再导入vue-router插件-->
<script src="https://unpkg.com/vue/dist/vue.js"></script>
<script src="https://unpkg.com/vue-router/dist/vue-router.js"></script>
<script>
    // 1. 声明路由需要使用到的组件
    const Foo = { template: '<div>foo</div>' }
    const Bar = { template: '<div>bar</div>' }
    // 2. 声明路由，每个路由应该映射一个组件
    const routes = [
        { path: '/foo', component: Foo },
        { path: '/bar', component: Bar }
    ]
    // 3. 创建 router 实例，然后传 `routes` 配置
    const router = new VueRouter({
        // (缩写) 相当于 routes: routes，这个名字是固定的
        routes 
    })
    // 4. 将声明好的router挂载进vue中就可以被调用了
    const app = new Vue({
      router
    }).$mount('#app')
</script>
```



## 黑云播放器整合实现路由切换

1.  实现最终效果演示
2.  实现步骤分析
    1.  导包，导入vue的路由
    2.  用包，拆分每个组件
    3.  将组件挂载到路由上
3.  代码结构演示
4.  开发过程演示
5.  所用知识及注意事项小结



##  黑云播放器 - 路由高亮样式

>   2.  给router-link添加一个属性  active-class='XXXX类名'
>   3.  vue-router 就会在我们切换`router-link`时，自动添加和移除 `XXXX类名` 
>   4.  给这个类名添加css高亮样式，就实现了路由高亮样式

```html
<router-link active-class='active'>导航</router-link>
```



##  黑云播放器 - 歌曲搜索实现分析

>   1.  顶部的搜索框双向数据绑定`v-model.trim :search`
>   2.  点击搜索或者点击回车
>       1.  @click @keyup.enter :searchMusic
>   3.  searchMusic方法，首先要将**搜索组件**显示出来
>   4.  searchMusic方法，还要将我们**搜索关键字**作为参数传递给**搜索组件**
>   5.  在js中控制显示组件 - **编程式导航** this.$router.push("/")
>   6.  在路由中传递参数 - **动态路由匹配** 



## VueRouter - 编程式导航

>   1.  咱们前面学过vue路由切换的一种方式，使用router-link 类似于使用a标签写好了直接跳转路由，这个有个专业的称呼叫做**声明式导航**
>   2.  如果我们希望，类似 `window.location.href = '地址'` 这种通过js脚本来控制路由跳转，在Vue是怎么办到的呢？OK，这个也有个专业的名称叫做**编程式导航**
>   3.  编程式导航使用起来非常非常简单：`this.$router.push('路由地址')`

声明式导航的本质是

```html
<a href='/run'>去跑步</a>
<router-link to='/run'>去跑步</router-link>
```

编程式导航的本质是

```js
window.location.href = '地址'
this.$router.push('地址')
```

适用情景

1.  声明式导航：点了就跳转，没有任何逻辑，类似于(a标签设置了href)
2.  编程式导航：跳转的同时有其他逻辑需要执行
3.  面试经常会问大家编程式导航和声明式导航是什么？有什么区别？



## VueRouter - 动态路由匹配

>   1.  什么是动态路由匹配？
>       1.  如果在切换路由的时候传递参数，我们会这样写：`href="http://baidu.cn?keyword=美丽祖国"`，这个url中会通过get的方式传递一个参数keyword，这个参数的值是”美丽祖国“
>       2.  在前端路由中是如何传递参数呢？首先，前端路由传递参数有一个高大上的叫法：**动态路由匹配**
>       3.  动态路由匹配，就是前端路由传递参数的方法
>   2.  如何实现动态路由匹配？
>       1.  第一步：修改路由规则定义，将 `/user`修改为`/user/:key`，其中的`:key`是一个占位，名字可以自己取
>       2.  第二步：在调用这个路由的时候记住传递参数
>           1.  声明式导航调用，直接使用 `/user/传递的参数值`即可
>           2.  编程式导航调用，使用 `this.$router.push('/result/传递的参数值')`即可
>       3.  第三步：路由切换完成后，在对应的页面里就可以通过 `this.$route.params.XXX名字（和Key对应）`拿到我们传递过来的参数然后使用了



##  黑云播放器 - 歌曲搜索路由设置

>   1.  顶部的搜索框双向数据绑定：`v-model.trim :search`，点击搜索或者点击回车调用方法：`@click @keyup.enter :searchMusic`
>   2.  把搜索的内容，传递给 搜索组件，咱们使用的是**动态路由匹配**，（可以在路由地址上传递参数）`/result=>/result/:search`
>   3.  再使用 **编程式导航**（用代码的方式实现跳转）让搜索组件显示出来 `this.$router.push('/result/${this.search}')`



## 黑云播放器 - 搜索结果实现分析

>   1.  路由切换显示`Result搜索结果组件`对应的页面
>
>   2.  在当前路由页面中，获取传递过来参数 `this.$route.params.键`
>   3.  搜索歌曲，数据获取到之后，渲染到页面上
>       1.  搜索歌曲使用：`axios.get( url ).then().catch()`
>       2.  渲染歌曲列表到页面上：`v-for : musicList`

 

## created生命周期钩子函数

>   1.  当路由切换，Result搜索结果组件对应的页面显示出来以后，我们希望用户能够尽早看到请求的数据结果，我们使用哪个钩子函数来请求数据比较合适呢？
>   2.  回忆生命周期钩子函数，我们发现mounted和updated都太晚了，是不是有更早的执行时机？数据创建完成created钩子函数是不是更早一些，我们在这里执行数据请求，可以让用户早一些看到数据
>   3.  回顾总结我们常用的生命周期钩子函数调用的时机
>       1.  created这个钩子函数，是Vue实例被创建，传入的data参数已经设置给这个Vue实例了，所以，如果要操纵数据最起码要在created这个时间点上，一般情况下默认发送的数据请求就放在这里
>       2.  mounted，数据和页面已经关联起来，完成了渲染，这一步DOM元素已经可以获取到，也就是说要获取操作DOM元素，最起码要在mounted这个时间点上，我们使用ref获取操作dom节点我们放在这里
>       3.  updated，data数据发生了更新，并渲染到了页面上后，触发的钩子函数，我们更改数据后调用我们自己的逻辑，一般都放在这里



## 黑云播放器 - 搜索结果功能实现

>   1.  当路由切换，Result搜索结果组件对应的页面显示出来以后，使用`this.$route.params.键`获取传递过来的参数
>   2.  拿到我们传递过来的参数，发送axios数据请求
>       1.  使用生命周期钩子（自动执行）created
>   3.  尽可能早一些执行的，让用户早一些看到数据
>   4.  数据获取到之后，渲染到页面上  `v-for : musicList`



## 黑云播放器 - 使用过滤器处理数据

>   1.  提出问题：现在我们的数据已经拿到了，并显示到了页面上，但是还有两个小问题
>       1.  一个是名字只显示了一个
>       2.  一个是时间显示不对
>   2.  我们采用什么方法解决呢？就是咱们之前学习到的**过滤器 filters**处理歌手名、处理时间



## 课程目标回顾

-   能够使用Vue.component注册全局组件
-   能够使用props把父组件给子组件传值
-   能够说出单页应用的优缺点
-   能够使用路由切换不同组件
-   能够使用编程式导航
-   能够使用动态路由匹配
-   理解Vue生命周期钩子函数created



## 课后预习

>   1.  安装vue-cli脚手架，[脚手架](https://cli.vuejs.org/zh/guide/) 
>   2.  安装vue-cli脚手架，[安装](https://cli.vuejs.org/zh/guide/installation.html)  npm install -g vue-cli
>   3.  按照官方文档，[创建项目输出基本页面](https://cli.vuejs.org/zh/guide/creating-a-project.html)   vue create XX

PS：安装或者下载的常见解决办法

>   1.  更换网络环境：无线换有线、有线换4G
>   2.  翻墙再下载
>   3.  更换安装的工具
>       1.  `cnpm` ：`cnpm install -g @vue/cli`
>       2.  `yarn` :`yarn global add @vue/cli`
>       3.  **修改npm下载源配置**
>           1.  npm config list 查看npm下载配置
>           2.  npm config set registry https://registry.npm.taobao.org
>   4.  **清除npm缓存之后，重新安装**（安装失败重新安装前，强烈建议先初始化）
>       1.  `npm cache clean -f`
>       2.  重新执行安装的命令
>   5.  使用管理员身份进行安装
